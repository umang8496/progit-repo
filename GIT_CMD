$sudo apt-get install git
$sudo apt install git-all
$which git

>>>git --version
>>>git init
>>>git status
>>>git clone <SSH|URL> : gives the cloned version of the repository with master branch

>>>git config --global user.name "<user_name>"
>>>git config --global user.email <user_email>
>>>git config --global core.editor <editor_name> or <editor_path>

>>>git add <filename>
>>>git commit -m "<commit_msg>"

Never amend a commit that has been pushed to the remote repository
>>>git commit --amend --no-edit
>>>git commit --amend

>>>git remote add origin https://github.com/umang8496/progit_repo.git
>>>git push -u origin master

>>>git diff : displays what has been changed but not yet staged
>>>git diff --staged|--cached : compares staged changes to the last commit 
>>>git diff --color-words <file_name>

>>>git log --oneline
>>>git log --oneline --decorate --graph --all
>>>git log --oneline <branch_name> : shows the logs corresponding to the specified branch
>>>git log --stat --oneline -n <number>
>>>git log -p
>>>git log --oneline <filename> : displays the logs corresponding to the specified file
>>>git log --follow [file] : lists version history for a file, including renames
>>>git log --format=oneline : [format --> full, short, medium, fuller, email, raw]
>>>git log <SHA>..<SHA> --oneline <file_name>
>>>git log --stat --summary
>>>git log <branch_name> --oneline -<number> : it will show n number of logs for a branch

In GIT, checkout is the act of switching between different versions of a target entity
It operates on three distinct entities, files, commits and branches
>>>git checkout -- <filename> : discards the changes made to the file when it is in unstaged state
>>>git checkout <SHA> -- <file_name> : bring the specified file in sync with the earlier version of itself corresponding to the commit

>>>git checkout -b <branch_name> : create a new branch and switch to it
>>>git checkout <branch_name> : simply switch to the specified branch
>>>git checkout --force|-f <branch_name>

>>>git branch : displays the current branch
>>>git branch <branch_name> : creates a branch with the specified name
>>>git branch -m <existing_branch_name> <new_branch_name> : renaming a branch
>>>git branch -d <name-of-the-branch> : does not delete the unmerged branches 
>>>git branch -D <name-of-the-branch> : deletes the unmerged branches too
>>>git branch --merged : tells us what branch has been incorporated into the current branch

>>>git rm <filename> : removes the file from the staging area as well as working tree
>>>git rm --cached <filename> : removes the file from tracking state but keeps it on the hard drive

>>>git mv <file_from> <file_to> : used to rename a file and put the changes into staging area

>>>git push <remote> <branch> : GIT won't let us push when it results in a non-fast-forward merge in the destination repository
>>>git push <remote> --force|-f : pushes the commits and objects even if it results in a non-fast-forward merge
>>>git push <remote> --all : pushes all the local branches to the specified remote
>>>git push origin :<branch-name> : this would delete the branch from the remote server [older method]
>>>git push origin --delete <branch-name> : this would delete the branch from the remote server [newer method]

>>>git fetch <remote> : fetches all the branches from the repo and downloads all of the required commits and files from the repo
>>>git fetch <remote> <branch> : only fetches the specified branch
>>>git fetch --all|-a : fetches all registered remotes and their branches
>>>git fetch --dry-run : shows what would be done, without making any changes

>>>git stash : takes the uncommitted changes (staged and unstaged) and saves them away for later use
>>>git stash pop : removes the changes from the stash and reapplies them to our working tree
>>>git stash apply : reapplies the changes to the working tree and also keeps them in our stash (recommended)
>>>git stash show : shows the summary for all the stashes
>>>git stash show --patch|-p : shows the full diff of the stash
>>>git stash list : lists all the stashes
>>>git stash save "<stash_msg>" : saves a stash with the specified message
>>>git stash drop <stashID> : drops a particular stash
>>>git stash clear : clears the entire stash
>>>git stash --include-untracked|-u : to stash untracked files also
>>>git stash --all|-a : stashes everything including ignored files

This removes only the untracked files from the working directory.
>>>git clean -n : performs a dry-run of git clean; shows which files are going to be removed without actually removing them
>>>git clean -f|--force : initiates the actual deletion of the untracted files from the current directory

>>>git revert <SHA> : for undoing changes but does not remove the commit from the project history
>>>git revert HEAD --edit|-e : default option which will open the configured system editor and prompts us to edit the commmit message
>>>git revert HEAD --no-edit|-n : the revert will not open the editor
>>>git revert HEAD --no-commit|-n : this option will prevent git revert from creating a new commit that inverses the target commit.
				    Instead  this option will add the inverse changes to the Staging Index and Working Directory.

>>>git reset --soft|--mixed|--hard <SHA>
>>>git reset HEAD <file_name> : for unstaging the changes, we use the reset option
>>>git reset --hard : reset staging area and working directory to match most recent commit and overwrites all the changes in the CWD

--soft
does not change staging index or working directory; just moves the HEAD pointer to the previous commit.

--mixed (default)
moves the HEAD pointer to the specified commit and also changes the staging index to match the repository.
but does not change the working index.

--hard
moves the HEAD pointer to the specified commit and it changes the staging index as well as the working directory to match.
#
#
#
